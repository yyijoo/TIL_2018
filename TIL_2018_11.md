 TIL @181121(수)



- 컴퍼넌트에서의 constructor
  - Constructor는 Initial state와 method를 만들어줘야할 때 쓴다.
  - mount되기 전에 실행된다.
  - super(props)는 constructor 안에서 props를 써줘야할 때 쓴다.
  - 참고 :  https://reactjs.org/docs/react-component.html#constructo
  - 참고 : https://stackoverflow.com/questions/30571875/whats-the-difference-between-super-and-superprops-in-react-when-using-e
  - constructor가 필요 없는 이유는 babel이 알아서 컴파일 해주기 때문이다. 
  - 참고 :  https://hackernoon.com/the-constructor-is-dead-long-live-the-constructor-c10871bea59
  - 데이터를 불러오는 함수는 componentDidMount 안에서 하는 게 좋다. 왜냐? componentDidMount에서 데이터 불러와야 에러를 일으킬만한 undefined state를 만들지 않는다. (가령, 데이터를 먼저 fetching 했는데 fetching한 데이터를 뿌려줄 부분이 render 안되어있으면 에러난다) 또, 서버사이드 렌더링할 때 componentWillMount에서 데이터 fetching하면 fetching이 2번 된다. 한 번은 서버에서 한 번은 클라이언트에서.
  - 참고 :  https://daveceddia.com/where-fetch-data-componentwillmount-vs-componentdidmount/



TIL @181122(목)



- mapping list
  - list의 개별 항목을 mapping해서 보여줄 때, 개별 항목을 별도의 component로 만들어야 한다. 별도의 component로 만들지 않아도 개별 항목을 보여줄 수는 있다. 하지만 개별 항목별 component를 만들어야 component별 state를 관리할 수 있고, 그래야 항목별 조건부 렌더링이 가능해진다. ex) 선택한 element 에서만 특정 div를 보여주고 싶다.



- React State vs Redux Store? 데이터를 React State로 만들어 관리하는 것과 Redux Store에 저장하는 것 비교.

  - Short-term 데이터는 ? React State 
    - state가 빠르게 바뀔 때. ex) 전체 form을 state로 바꿀 때. form이 제출되기 전까지는 work in progress 상태인 것.  show/hide item할 때, 리스트의 아이템 필터링할 때 등.

  - Mid-term 데이터는 ? Redux Store
    - 유저가 앱을 navigate할 때 따라다녀야 하는 state. API로부터 불러와진 data나 페이지가 refresh 될 때까지 붙어있어야하는 데이터다. ex) form을 제출하고 나서의 state는 store에 저장되도록 한다. 
  - Long-term 데이터는? Redux Store
    - 페이지 refresh하거나 페이지를 이동할 때, 각기 다른 페이지를 방문할 때에도 계속 붙어있어야 하는 state는 store 저장한다. 리덕스 스토어는 새로고침할 때 갱신된다.

  -  얼마나 많은 component가 동일한 state에 접근해야하는가? 여러 컴퍼넌트가 동일한 state를 share하면 할 수록 redux store를 쓰는 가치가 있다. 
  - props를 내려주는 depth가 어떤가? 1-2단계만 내려줄 때는 리액트 괜찮다. 그 이상이면 귀찮다.
  - 서로 상관없는 component들이 같은 state에 접근해야할 때는 store가 낫다. ex) 유저 정보를 userprofile 컴퍼넌트와 user header에서 모두 써야 함. —> store 에 유저 정보를 저장하고 각기 가져다 써라. 
  - state change를 트랙킹해야하는가? store가 좋다.
  - app의 다른 부분이 이 data를 알아야하는가? Redux Store
  - 이 data로부터 파생된 다른 데이터를 만들어내야하는가? Redux Store
  - 복수의 컴퍼넌트에서 이 데이터가 사용되는가? Redux Store
  - 즉시 state에 재저장되어야하는 value가 있는가? Redux Store
  - data를 cache하고싶은가? Redux Store. ex) 해당 데이터가 이미 state에 있는 경우 재요청하지 않고 그 데이터를 사용하고싶은 경우 
  - 참고 : https://spin.atomicobject.com/2017/06/07/react-state-vs-redux-state/
  - 참고 : https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367



TIL @181123(금)

- map 메소드를 사용해 리스트 만들 때 key props
  - Key 값은 html 렌더링할 때 변경된 html만 효율적으로 렌더링하기 위해 필요하다. 즉, 최적화를 위한 것. ul 태그의 자식 노드들을 반본적으로 비교하며 변경된 내용만 렌더링 한다. 
  - Index 값을 key로 설정하는 건 부적절하다. 리스트 아이템이 바뀌면 index도 함께 바뀌기 때문.
  - key props는 컴포넌트의 엘레먼트로 전달되지 않는다. 전달받으려면 다른 props에 담아서 전달해야 한다.
  - 참고 : http://beomy.tistory.com/29

- Redux 사용할 때의 React-Router

  - 기존 web app navigation 방식 vs 리액트 라우터를 사용한 navigation 방식
    - 기존 : 유저가 웹브라우저에 url을 친다 -> 서버에 request를 날린다 -> 서버가 해당 url에 맞는 html page를 응답한다. 
    - 리액트 라우터 : 페이지를 이동할 때마다 요청하지 않는다. history라는 패키지를 쓴다. 이는 리액트라우터 깔면 자동으로 세팅된다.  history가 url을 받고 파싱한 다음 react-router 라이브러리에 새로운 url로 요청한다. react-router는 해당 url에 맞는 컴퍼넌트를 돌려준다. 하나의 html document 안에서 url에 따라 다른 component set을 보여주는 것이기에 'single page application'이라고 부른다. 별도의 web sever에 의해 만들어진 각기 다른 html 문서들을 navigationg하지 않는다는 의미다. 

  - React-Router 사용법

    - react-router-dom에서 BrowserRouter와 Route를 import한다. BrowserRouter는 history 라이브러리와 상호작용하고 해당 url에 맞게 뭘 할지를 결정한다. Route는 하나의 리액트 컴퍼넌트다. 우리가 함께 넣을 컴퍼넌트들이 여기에 들어간다. 각기 다른 url에 따라 보여줄 component들을 render하는 component라는 의미인 듯 하다.

      ~~~javascript
      import { BrowserRouter, Route } from 'react-router-dom';
      import PostsIndex from './components/posts_index';
      
      <BrowserRouter>
          <div>
          <Route path="/" component={PostsIndex} />
          </div>
      </BrowserRouter>
      ~~~

    - 리액트 라우터를 사용할 경우 redux store도 이에 맞게 바꿔준다.  여러 리스트에서 한 아이템을 선택해, 선택된 아이템만 보여주는 경우 기본적으로 선택된 아이템을 위한 state를 따로 만든다. 하지만 그럴 필요 없다. routing되는 url도 하나의 중요한 state라고 볼 수 있다. 선택한 post id = 선택한 url의 파라미터다. 전체 리스트를 배열 안의 객체 형식[ {id:1, title: "글 제목1"}, {id:2, title:"글 제목2"} ] 이었던 걸 — > 객체 안의 객체 { 0: {id:1, title: "글 제목1"}, 1: {id:2, title:"글 제목2"}}로 관리해서 특정 url일 때 특정 key 값을 보여주게 만들 수 있다. 이 때 lodash라는 라이브러리를 사용한다.  

      ~~~javascript
      const posts = [
          {id: 4, title: "Hi"},
          {id: 25, title: "bye"},
          {id: 36, title: "Hows it going"}
      ];
      
      // lodash library를 사용한다. 
      import _ from 'lodash';
      const state = _.mapKeys(posts, 'id') // state["4"]로 선언 시 {id: 4, title: "Hi"}가 반환된다.
      
      ~~~



TIL @181124(토)

- Redux 사용할 때의 React-Router

  - fetching해온 데이터를 reducer에서 lodash를 사용해 바꿔 저장한다. 

    ~~~javascript
    import _ from 'lodash';
    import {FETCH_POSTS} from '../actions';
    
    export default function(state={}, action) {
        switch (action.type) {
            case FETCH_POSTS:
                return _.mapKeys(action.payload.data, 'id');
        }
        default:
        return state
    }
    ~~~


- HTTP DELETE 요청 시 서버에서 body로 받을 수 있게 하는 방법

  - HTTP 통신규약에 따르면 delete 요청 메소드에는 body 없음

  - 참고 : https://developer.mozilla.org/ko/docs/Web/HTTP/Methods/DELETE

  - 참고 : https://stackoverflow.com/questions/299628/is-an-entity-body-allowed-for-an-http-delete-request

  - 하지만 서버에서 body로 받아야할 때는 key 이름을 data로 설정하고 header에 함께 담아 보낸다. 

    ~~~javascript
    const header = {
      headers: {
        id: 1,
      }
    }
    
    // delete 요청하는데 body에 data를 실어보내는 경우 응답받지 못한다.
    export const deleteUserProfile = (data, part) => axios.delete(`${URL}/user/${part}`, data, header);
    
    
    // 아래와 같이 하나의 객체에 header 항목들을 담아서 보내야 한다.
    export const deleteUserProfile = (data, part) => axios.delete(`${URL}/user/${part}`, { data, ...header });
    
    ~~~

  - 참고 : https://github.com/axios/axios/issues/897

  - 추가 참고 : DELETE 요청 시 params로 주고받을 때 client & server 코드

    ~~~javascript
    // data = {id: 5}
    
    // Client
    export const deleteUserProfile = (data, part) => axios.delete(`${URL}/user/${part}/${data.id}`, header);
    
    
    // Server
    router.delete("/education/:id", async (req, res, next) => {
      try {
        await Education.destroy({
           where: { id: req.params.id }
         });
        const data = await profileSaver(req.headers.id);
        res.json(data);
      } catch (err) {
        next(err);
      }
    });
    ~~~

  - (공부 필요) HTTP 통신규약에 대한 공부 & RESTful한 API 설계



TIL @181125(일)

- Scotty를 사용한 single page app 배포 방법 ( [Single command deployment for single page apps](https://hackernoon.com/single-command-deployment-for-single-page-apps-29941d62ef97) )

  1) app build (npm run build)

  2) scottyjs 설치 : npm install scottyjs -g

  3) AWS credential 세팅 

  - 세팅을 하려면 1) [aws-cli 설치를 하고](https://docs.aws.amazon.com/ko_kr/cli/latest/userguide/installing.html) 2) [aws-configure로 나의 aws 계정을 연결해놓으면](https://docs.aws.amazon.com/ko_kr/cli/latest/userguide/cli-chap-getting-started.html) 된다. 
  - aws-cli 설치 : pip와 번들깔기 둘 다 시도했지만 aws를 실행하면 not found... 이런 경우 명령줄 경로에 AWS CLI 실행 파일을 추가하라는데 (2번 참고 링크의 '명령줄 경로에 AWS CLI 실행 파일 추가 참고') 제대로 추가를 못 했는지 실패. 결국 brew로 설치했다.
  -  aws-configure할 때 IAM 리소스 키를 등록

  4) build 폴더가 있는 폴더에서  scotty --spa --source ./build

  - ....를 했으나 ACCESS DENIED... IAM 권한 문제거나 S3 bucket 권한 문제로 추측



TIL @181126(월)

- 소셜 로그인 버튼 포맷 맞추는 거 서비스별로 당연히 쉽게 만들어놨을 줄 알았는데 그렇지 않다. 급한 대로 라이브러리 써서 서비스별 색깔만 맞췄다. 

  - [react-social-login-buttons 라이브러리](https://www.npmjs.com/package/react-social-login-buttons)

- AWS S3 버킷 정책 만들 때 '권한 없음'이라며 등록이 안된다면 '권한>퍼블릭 액세스 설정'에서 퍼블릭ACL관리 , 퍼블릭 버킷 정책 관리의 4개 항목을 모두 False로 바꿔주면 된다.





TIL @181127(화)

-  git stash는 하던 작업을 저장하고 가장 최근 commit 상태로 만든다. 

  - git stash는 작업하던 걸 임시로 저장해두고 필요할 때 가져다 쓰고 있었는데 정확히 '언제 시점부터의 상태'를 저장하는지 정확히 모르고 있었다. 워킹 디렉토리에 unstasged 파일들을 백업하고, 워킹 디렉토리를 깨끗한 상태로 만든다.

  - 참고 : [git의 요술 책갈피, Stash 기능 소개](http://wit.nts-corp.com/2014/03/25/1153)
  - 특정 커밋으로 돌아가려면 git checkout 686d1a (git checkout 커밋 id)

- google Vision API 사용하는 법 

  https://cloud.google.com/vision/docs/quickstart

  - client에서 보내기 vs server에서 보내기
    - server에서 보낼 땐 Node.js용 [라이브러리](https://cloud.google.com/vision/docs/libraries#client-libraries-usage-nodejs) 사용한다.
    - client에서 보낼 때, 이미지를 base64로 바꿔서 보내야 한다.





TIL @181128(수)

- 유저의 컴퓨터에 저장되어있는 이미지 파일을 base64로 string으로 바꾸는 법

  - base64란 ? 실행 파일, ZIP파일과 같은 8비트 이진 데이터를 ASCII 영역의 문자들로만 이루어진 일련의 문자열로 바꾸는 인코딩 방식.
    - 참고 : [위키: 베이스64](https://ko.wikipedia.org/wiki/%EB%B2%A0%EC%9D%B4%EC%8A%A464)

  - type이 file인 input으로 이미지를 받고, FileReader object를 사용한다.

    - 참고 : [React-TypeScript 프로덕트에 HTML5 canvas와 Google Vision API를 활용한 인물사진 유효성 검사하기](https://velog.io/@clarekang/react-ts-canvas-photo-upload)

    - 참고 : [MDN: readAsDataURL](https://developer.mozilla.org/ko/docs/Web/API/FileReader/readAsDataURL)

      - 컨텐츠를 특정 Blob나 File에서 읽어옴. 읽어오는 read 행위가 종료되면 readyState 상태가 Done되고 loaded 이벤트가 트리거 됨. 이와 함께 Base64 인코딩 된 스트링 데이터가 result 속성에 담겨짐.


    ~~~javascript
    // 1. type이 file인 input으로 이미지를 받고, 
    <input
      type="file"
      id="img"
      name="image"
      onChange={e => this.handleOnFileUpload(e)}
     />
    
    // 2. FileReader object를 사용해 base64로 바꾼다.
    
    handleOnFileUpload = e => {
        const file = e.target.files[0];
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => {
          console.log('reader.result', reader.result); // loaded 이벤트가 트리거되면 result에 Base64 인코딩된 스트링 데이터가 result에 담긴다.
          const imageData = reader.result.split(',')[1]; // data:image/png;base64와 같은 prefix를 제외해준다. 
          console.log('imageData', imageData); // 이제 요청할 순수 이미지 base64 string만 남았다.
            
        };
      };


​    
​    ~~~

  - string으로 바꾼 이미지 데이터를 body에 담아 postman으로 요청해봤는데 빈 response가 돌아온다. 왜?

    ```javascript
    {
        "responses": [
            {}
        ]
    }
    ```

    - key를 data로, request body에 들어갈 obejct를 value로 만들어서 보내봤다. 빈 response가 돌아오진 않는다....하지만.... 아래 항목으로

    - 참고 : [stackoverflow: Empty response from Google Vision API with an image stored in Google Cloud Storage](https://stackoverflow.com/questions/35687208/empty-response-from-google-vision-api-with-an-image-stored-in-google-cloud-stora)

  - 하지만.... 400에러

    - header에 content-Type을 지정한다. 보낼 data는 json stringify시켜서 보냈다. 성공!

    - 참고 : [stackoverflow: Problems with POST to Google Vision Via Javascript](https://stackoverflow.com/questions/44862532/problems-with-post-to-google-cloud-vision-via-javascript)

    - 참고 : [stackoverflow: Response 400 from Google Vision API OCR with a base64 string of specified image](https://stackoverflow.com/questions/49918950/response-400-from-google-vision-api-ocr-with-a-base64-string-of-specified-image?noredirect=1&lq=1)


TIL @181129(목)

- API key 저장 방법
  - Server : .env파일에 API key를 저장한다. (ex. API_KEY = 'dfasdfwafwafdsafawfwef') 사용할 때는 process.env.API키명으로 불러와 쓴다. (process.env.API_KEY)
  - Client
    - 안전하게 하려면 server를 통해 API 콜 해야하나보다. 더 찾아봐야 함.
      - 참고 : [Google API Client Libraries > JavaScript](https://developers.google.com/api-client-library/javascript/start/start-js)
    - 익숙한 대로 일단 API key를 저장하기 위한 문서를 만들고, 이 문서를 git ignore하도록 했다.
      - src 파일 아래 config 파일을 만들고 google.js 파일 안에 export const GoogleVision_API_KEY = 'fdsafsafawefw'로 설정 --> 해당 API KEY를 써야하는 파일에서 import해서 사용 --> .gitignore파일에 google.js 파일을 추가.

- 소셜 로그인 시 토큰 처리

  - mydiary 프로젝트 때 카카오 로그인 시 토큰을 저장한 방법 (client-side)

    1) 카카오 로그인 버튼을 누르면 href 속성으로 kakao auth로 연결되도록 한다. 

    - (클라이언트 처리 X) 연결되면 아래와 같은 과정이 이루어짐
      - 카카오 로그인 창 뜸 --> 유저가 이메일, 비밀번호 입력 후 submit --> mydiary 서버에서 카카오 서버로 회원 확인 요청 --> 카카오 서버에서 회원 여부 확인 후 응답 --> mydiary 서버에서 카카오 서버로부터 응답 받고 토큰을 만들어서 클라이언트로 응답. 응답할 때는 url에 params로 전달됨.

     2) 클라이언트에서 응답을 받아 로컬에 토큰을 저장한다.

     ㄴ queryString.parse(this.props.location.search)해서 params로 넘어온 데이터를 parse.

      ㄴ 여기서 this.props.location.search는 react-router-dom 패키지를 사용해 해당 컴퍼넌트를 Router로 감싸준 경우 알아서 처리해준다.

     ㄴ parse한 데이터를 localStroage.setItem으로 로컬에 저장. 

    3) PrivateRouter로 만약 localStorage에 토큰이 있으면 저장되게 처리

    - 토큰이 없으면 loaded를 true로 설정
    - 토큰이 있으면 서버로 해당 토큰이 해당 회원 것 맞는지 get 요청으로 확인

- 클라이언트 S3 배포 시 다른 router로는 직접 접근이 불가능하다. 그래서 (편법으로) 버킷 속성에서 static website hosting설정할 때 error document도 index.html로 설정해줘야 한다. 

  - 참고 : [Host your react-redux website with AWS S3](https://dev.to/brightdevs/host-your-react-redux-website-with-aws-s3-57fi)

- 18/11/25 에 실패했던 scotty를 사용한 클라이언트 S3 배포 성공! 전에 S3 권한을 퍼블릭으로 바꿔줘서 그런가 봄. 





TIL @181130(금)

- (궁금) 서버에서 라우터를 잘게 쪼개서 HTTP 처리 vs 라우터 단순하게 만들고 클라이언트에서 동일한 라우터에 정보를 매번 덜 담아서 처리하는 것 중 뭐가 나을지?
  - HTTP 요청할 때 서버에서 정의한 데이터보다 덜 보내거나 더 보내는 게 어떤 영향이 있을까?

- 유저 프로필 페이지에서 유저 정보 삭제 버튼을 누르면, DB에 유저 정보을 빈 스트링으로 post 처리함 (유저의 정보를 DB에서 delete하는 게 아니라). -----> DB와 store에는 빈 스트링으로 잘 반영되어있음 ---> 하지만 re-render되지 않고 삭제 전 정보가 보임.
  - store에서 데이터를 props로 땡겨오기 때문에 자동으로 컴퍼넌트가 re-render될 거 같은데 왜지?
  - 급한 대로 수동으로 빈 스트링들을 setState 해주었다.
  - 수동으로 re-render 시킬 때는 shouldComponentUpdate를 쓰는 듯. (공부 필요)
- (공부 필요) 최적화를 위한 코드 스플리팅
- (공부 필요) sass, styled component





TIL @181201(토)

- Sass & SCSS & Styled Component 중에 뭘 적용해볼까? ---> 여러 개의 글을 읽어본 결과 단기간 내 효용을 크게 느끼려면 리액트에 최적화된 것으로 보이는 Styled Component가 적절한 걸로 보임.

  - 참고: [Sass강좌-한 눈에 보기](https://velopert.com/1712)

    | SaSS(Syntactically Awesome Style Sheets)                     | SCSS                                                         |
    | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | CSS pre-processor로 CSS를 확장해서 쓸 수 있도록 해줌. 컴파일러로 브라우저에서 사용 가능한 일반 CSS문법으로 바꿔줘야 함. | Sass가 처음 나왔을 때 CSS와 사용 방법이 많이 달랐는데 버전3 이상부터 주 문법이 CSS와 문법이 동일한 SCSS로 변경되었다. 즉, SCSS는 CSS와 문법이 동일한데 sass만의 기능이 추가된 거다. |

  - Sass vs. SCSS 비교 ---> 하단 참고글 글쓴이는 SCSS에 적응하는데 시간이 걸리기는 했지만 원래의 Sass 문법보다 SCSS를 선호하게 되었다고 함.

    - Sass
      - SCSS에 비해 문법이 더 간결. (Indented syntax는 세미콜론과 {}를 쓸 필요가 덜함. @include를 번복할 필요가 덜함. 대신 +를 씀 등등)
      - 읽기 더 편함. (indentation 강제함)
      - 세미콜론 안 넣어도 뭐라 안함
    - SCSS
      - 가독성은 sass가 좋지만 SCSS가 더 표현하기에 좋음. 좀 지저분해도 몇 개 속성, value에 내가 옵션을 줄 수 있는 게 좋았다고.   
      - selector 안에 nest selector를 지원함. 편하긴 한데 자꾸 nest가 깊어짐. selector가 매우 길어진다. 이렇게 되면 css 파일 사이즈가 커질 뿐 아니라 다른 rules를 덮어쓰기도 어려움. (재사용이 어렵다는 뜻인 듯)
      - 모듈화가 더 좋음 등등... 

    - 참고: [Sass vs. SCSS: which syntax is better?](http://thesassway.com/editorial/sass-vs-scss-which-syntax-is-better) (5 년 전 글이라는 점 염두)

    - Styled Component

      - SASS 단점: node-sass, sass-loader 등 모듈 설치 필요 + web pack confing를 수정해야하기 때문에 CRA로 프로젝트 생성한 경우 eject하는 작업 필요. lazily nesting에 의존해 컴파일된 스타일시트가 커짐.
      - Style Component는 컴퍼넌트 안에서 element에 직접 스타일을 준다. class 없음. 글로벌하게 스타일링 줄 수 있음. 상속 개념 있음. 여러 컴퍼넌트에서 동일한 CSS value 공유할 수 있음. 
      - 참고 : [Styled Components - 스타일을 품은 컴포넌트](https://hudi.kr/styled-components-%EC%8A%A4%ED%83%80%EC%9D%BC%EC%9D%84-%ED%92%88%EC%9D%80-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/)
      - 참고: [CSS의 진화 - CSS, SASS, BEM, CSS Modules로부터 Styled Components로](https://orezytivarg.github.io/css-evolution-from-css-sass-bem-css-modules-to-styled-components/)

- Redis
  - (공부 필요) 데이터를 하드디스크가 아니라 저장하는 store다. 처리 속도가 월등히 빠르기에 DB에 요청이 많을 때 사용한단다. Linked list, hash 등 다양한 자료구조를 지원한다.   

