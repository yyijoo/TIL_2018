TIL @181121(수)



- 컴퍼넌트에서의 constructor
  - Constructor는 Initial state와 method를 만들어줘야할 때 쓴다.
  - mount되기 전에 실행된다.
  - super(props)는 constructor 안에서 props를 써줘야할 때 쓴다.
  - 참고 :  https://reactjs.org/docs/react-component.html#constructo
  - 참고 : https://stackoverflow.com/questions/30571875/whats-the-difference-between-super-and-superprops-in-react-when-using-e
  - constructor가 필요 없는 이유는 babel이 알아서 컴파일 해주기 때문이다. 
  - 참고 :  https://hackernoon.com/the-constructor-is-dead-long-live-the-constructor-c10871bea59
  - 데이터를 불러오는 함수는 componentDidMount 안에서 하는 게 좋다. 왜냐? componentDidMount에서 데이터 불러와야 에러를 일으킬만한 undefined state를 만들지 않는다. (가령, 데이터를 먼저 fetching 했는데 fetching한 데이터를 뿌려줄 부분이 render 안되어있으면 에러난다) 또, 서버사이드 렌더링할 때 componentWillMount에서 데이터 fetching하면 fetching이 2번 된다. 한 번은 서버에서 한 번은 클라이언트에서.
  - 참고 :  https://daveceddia.com/where-fetch-data-componentwillmount-vs-componentdidmount/



TIL @181122(목)



- mapping list
  - list의 개별 항목을 mapping해서 보여줄 때, 개별 항목을 별도의 component로 만들어야 한다. 별도의 component로 만들지 않아도 개별 항목을 보여줄 수는 있다. 하지만 개별 항목별 component를 만들어야 component별 state를 관리할 수 있고, 그래야 항목별 조건부 렌더링이 가능해진다. ex) 선택한 element 에서만 특정 div를 보여주고 싶다.



- React State vs Redux Store? 데이터를 React State로 만들어 관리하는 것과 Redux Store에 저장하는 것 비교.

  - Short-term 데이터는 ? React State 
    - state가 빠르게 바뀔 때. ex) 전체 form을 state로 바꿀 때. form이 제출되기 전까지는 work in progress 상태인 것.  show/hide item할 때, 리스트의 아이템 필터링할 때 등.

  - Mid-term 데이터는 ? Redux Store
    - 유저가 앱을 navigate할 때 따라다녀야 하는 state. API로부터 불러와진 data나 페이지가 refresh 될 때까지 붙어있어야하는 데이터다. ex) form을 제출하고 나서의 state는 store에 저장되도록 한다. 
  - Long-term 데이터는? Redux Store
    - 페이지 refresh하거나 페이지를 이동할 때, 각기 다른 페이지를 방문할 때에도 계속 붙어있어야 하는 state는 store 저장한다. 리덕스 스토어는 새로고침할 때 갱신된다.

  -  얼마나 많은 component가 동일한 state에 접근해야하는가? 여러 컴퍼넌트가 동일한 state를 share하면 할 수록 redux store를 쓰는 가치가 있다. 
  - props를 내려주는 depth가 어떤가? 1-2단계만 내려줄 때는 리액트 괜찮다. 그 이상이면 귀찮다.
  - 서로 상관없는 component들이 같은 state에 접근해야할 때는 store가 낫다. ex) 유저 정보를 userprofile 컴퍼넌트와 user header에서 모두 써야 함. —> store 에 유저 정보를 저장하고 각기 가져다 써라. 
  - state change를 트랙킹해야하는가? store가 좋다.
  - app의 다른 부분이 이 data를 알아야하는가? Redux Store
  - 이 data로부터 파생된 다른 데이터를 만들어내야하는가? Redux Store
  - 복수의 컴퍼넌트에서 이 데이터가 사용되는가? Redux Store
  - 즉시 state에 재저장되어야하는 value가 있는가? Redux Store
  - data를 cache하고싶은가? Redux Store. ex) 해당 데이터가 이미 state에 있는 경우 재요청하지 않고 그 데이터를 사용하고싶은 경우 
  - 참고 : https://spin.atomicobject.com/2017/06/07/react-state-vs-redux-state/
  - 참고 : https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367



TIL @181123(금)

- map 메소드를 사용해 리스트 만들 때 key props
  - Key 값은 html 렌더링할 때 변경된 html만 효율적으로 렌더링하기 위해 필요하다. 즉, 최적화를 위한 것. ul 태그의 자식 노드들을 반본적으로 비교하며 변경된 내용만 렌더링 한다. 
  - Index 값을 key로 설정하는 건 부적절하다. 리스트 아이템이 바뀌면 index도 함께 바뀌기 때문.
  - key props는 컴포넌트의 엘레먼트로 전달되지 않는다. 전달받으려면 다른 props에 담아서 전달해야 한다.
  - 참고 : http://beomy.tistory.com/29

- Redux 사용할 때의 React-Router

  - 기존 web app navigation 방식 vs 리액트 라우터를 사용한 navigation 방식
    - 기존 : 유저가 웹브라우저에 url을 친다 -> 서버에 request를 날린다 -> 서버가 해당 url에 맞는 html page를 응답한다. 
    - 리액트 라우터 : 페이지를 이동할 때마다 요청하지 않는다. history라는 패키지를 쓴다. 이는 리액트라우터 깔면 자동으로 세팅된다.  history가 url을 받고 파싱한 다음 react-router 라이브러리에 새로운 url로 요청한다. react-router는 해당 url에 맞는 컴퍼넌트를 돌려준다. 하나의 html document 안에서 url에 따라 다른 component set을 보여주는 것이기에 'single page application'이라고 부른다. 별도의 web sever에 의해 만들어진 각기 다른 html 문서들을 navigationg하지 않는다는 의미다. 

  - React-Router 사용법

    - react-router-dom에서 BrowserRouter와 Route를 import한다. BrowserRouter는 history 라이브러리와 상호작용하고 해당 url에 맞게 뭘 할지를 결정한다. Route는 하나의 리액트 컴퍼넌트다. 우리가 함께 넣을 컴퍼넌트들이 여기에 들어간다. 각기 다른 url에 따라 보여줄 component들을 render하는 component라는 의미인 듯 하다.

      ~~~javascript
      import { BrowserRouter, Route } from 'react-router-dom';
      import PostsIndex from './components/posts_index';
      
      <BrowserRouter>
          <div>
          <Route path="/" component={PostsIndex} />
          </div>
      </BrowserRouter>
      ~~~

    - 리액트 라우터를 사용할 경우 redux store도 이에 맞게 바꿔준다.  여러 리스트에서 한 아이템을 선택해, 선택된 아이템만 보여주는 경우 기본적으로 선택된 아이템을 위한 state를 따로 만든다. 하지만 그럴 필요 없다. routing되는 url도 하나의 중요한 state라고 볼 수 있다. 선택한 post id = 선택한 url의 파라미터다. 전체 리스트를 배열 안의 객체 형식[ {id:1, title: "글 제목1"}, {id:2, title:"글 제목2"} ] 이었던 걸 — > 객체 안의 객체 { 0: {id:1, title: "글 제목1"}, 1: {id:2, title:"글 제목2"}}로 관리해서 특정 url일 때 특정 key 값을 보여주게 만들 수 있다. 이 때 lodash라는 라이브러리를 사용한다.  

      ~~~javascript
      const posts = [
          {id: 4, title: "Hi"},
          {id: 25, title: "bye"},
          {id: 36, title: "Hows it going"}
      ];
      
      // lodash library를 사용한다. 
      import _ from 'lodash';
      const state = _.mapKeys(posts, 'id') // state["4"]로 선언 시 {id: 4, title: "Hi"}가 반환된다.
      
      ~~~



TIL @181124(토)

- Redux 사용할 때의 React-Router

  - fetching해온 데이터를 reducer에서 lodash를 사용해 바꿔 저장한다. 

    ~~~javascript
    import _ from 'lodash';
    import {FETCH_POSTS} from '../actions';
    
    export default function(state={}, action) {
        switch (action.type) {
            case FETCH_POSTS:
                return _.mapKeys(action.payload.data, 'id');
        }
        default:
        return state
    }
    ~~~


- HTTP DELETE 요청 시 서버에서 body로 받을 수 있게 하는 방법

  - HTTP 통신규약에 따르면 delete 요청 메소드에는 body 없음

  - 참고 : https://developer.mozilla.org/ko/docs/Web/HTTP/Methods/DELETE

  - 참고 : https://stackoverflow.com/questions/299628/is-an-entity-body-allowed-for-an-http-delete-request

  - 하지만 서버에서 body로 받아야할 때는 key 이름을 data로 설정하고 header에 함께 담아 보낸다. 

    ~~~javascript
    const header = {
      headers: {
        id: 1,
      }
    }
    
    // delete 요청하는데 body에 data를 실어보내는 경우 응답받지 못한다.
    export const deleteUserProfile = (data, part) => axios.delete(`${URL}/user/${part}`, data, header);
    
    
    // 아래와 같이 하나의 객체에 header 항목들을 담아서 보내야 한다.
    export const deleteUserProfile = (data, part) => axios.delete(`${URL}/user/${part}`, { data, ...header });
    
    ~~~

  - 참고 : https://github.com/axios/axios/issues/897

  - 추가 참고 : DELETE 요청 시 params로 주고받을 때 client & server 코드

    ~~~javascript
    // data = {id: 5}
    
    // Client
    export const deleteUserProfile = (data, part) => axios.delete(`${URL}/user/${part}/${data.id}`, header);
    
    
    // Server
    router.delete("/education/:id", async (req, res, next) => {
      try {
        await Education.destroy({
           where: { id: req.params.id }
         });
        const data = await profileSaver(req.headers.id);
        res.json(data);
      } catch (err) {
        next(err);
      }
    });
    ~~~

  - (추가 공부 필요) HTTP 통신규약에 대한 공부 & RESTful한 API 설계

